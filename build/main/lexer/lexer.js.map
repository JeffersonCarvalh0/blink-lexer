{"version":3,"sources":["../../../src/main/lexer/lexer.js"],"names":["exps","Lexer","input","line","column","tokens","token","nextToken","type","TokenType","EndOfInput","push","length","Token","undefined","substr","slice","spaces","match","i","lexeme","createToken","Unrecognized","expId","keywords","Identifier","assignment","arithmetic","comparisson","boolean","delimiters","Integer","Decimal","String"],"mappings":"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","file":"lexer.js","sourcesContent":["import { Token } from './token'\nimport { TokenType } from './tokentype'\n\nconst exps = [\n    /^[_a-zA-Z][_a-zA-Z0-9]*/,  // identifiers, keywords\n    /^(=|\\/=|-=|%=|\\+=|\\*=)/,   // assignment operators\n    /^(\\/|%|-|\\+|\\*)/,          // arithmetic operators\n    /^(==|>|>=|<|<=|!=)/,       // comparisson operators\n    /^(&&|!|\\|\\|)/,             // boolean operators\n    /^(,|{|}|\\[|\\]|\\(|\\)|;)/,   // delimiters\n    /^\\d+/,                     // integer\n    /^[+-]?\\d+(\\.\\d+)?/,        // decimal\n    /^\"[\\w ]+\"/                 // string literal\n]\n\nexport class Lexer {\n    constructor(input, line) {\n        this.input = input;\n        this.line = line;\n        this.column = 0;\n    }\n\n    tokenize() {\n        let tokens = [];\n        let token = this.nextToken();\n\n        while (token.type !== TokenType.EndOfInput) {\n            tokens.push(token);\n            token = this.nextToken();\n        }\n\n        return tokens;\n    }\n\n    nextToken() {\n        if (this.column == this.input.length)\n            return new Token(TokenType.EndOfInput, undefined, this.line, this.column);\n        else {\n            let substr = this.input.slice(this.column);\n            let spaces = substr.match(/^\\s+/);\n            if (spaces) this.column += spaces.length, substr = this.input.slice(this.column);\n\n            for (let i = 0; i < exps.length; ++i) {\n                let lexeme = substr.match(exps[i]);\n                if (lexeme) {\n                    lexeme = lexeme[0];\n                    let token = this.createToken(lexeme, i);\n                    this.column += lexeme.length;\n                    return token;\n                }\n            }\n            return new Token(TokenType.Unrecognized, undefined, this.line, this.column);\n        }\n    }\n\n    createToken(lexeme, expId) {\n        if (expId == 0) {\n            for (let type in TokenType.keywords) {\n                if (lexeme == TokenType.keywords[type])\n                    return new Token(TokenType.keywords[type], lexeme, this.line, this.column);\n            }\n            return new Token(TokenType.Identifier, lexeme, this.line, this.column);\n        }\n\n        if (expId == 1) {\n            for (let type in TokenType.assignment) {\n                if (lexeme == TokenType.assignment[type])\n                    return new Token(TokenType.assignment[type], lexeme, this.line, this.column);\n            }\n        }\n\n        if (expId == 2) {\n            for (let type in TokenType.arithmetic) {\n                if (lexeme == TokenType.arithmetic[type])\n                    return new Token(TokenType.arithmetic[type], lexeme, this.line, this.column);\n            }\n        }\n\n        if (expId == 3) {\n            for (let type in TokenType.comparisson) {\n                if (lexeme == TokenType.comparisson[type])\n                    return new Token(TokenType.comparisson[type], lexeme, this.line, this.column);\n            }\n        }\n\n        if (expId == 4) {\n            for (let type in TokenType.boolean) {\n                if (lexeme == TokenType.boolean[type])\n                    return new Token(TokenType.boolean[type], lexeme, this.line, this.column);\n            }\n        }\n\n        if (expId == 5) {\n            for (let type in TokenType.delimiters) {\n                if (lexeme == TokenType.delimiters[type])\n                    return new Token(TokenType.delimiters[type], lexeme, this.line, this.column);\n            }\n        }\n\n        if (expId == 6) return new Token(TokenType.Integer, lexeme, this.line, this.column);\n        if (expId == 7) return new Token(TokenType.Decimal, lexeme, this.line, this.column);\n        if (expId == 8) return new Token(TokenType.String, lexeme, this.line, this.column);\n    }\n}\n"]}